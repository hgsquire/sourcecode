#!/usr/bin/env python3
"""
Confluence Cloud: Add users from CSV to a space by granting view + create permissions.

- Auth via INI section: url, username, pat
- CSV columns supported: accountId (best), email (best-effort lookup), query (name/email), anything else ignored
- Grants:
    read:space
    create:page
    create:blogpost
    create:comment
    create:attachment

Refs:
- Add new permission to space (POST /wiki/rest/api/space/{spaceKey}/permission)
- User search via CQL endpoint (/wiki/rest/api/search/user)
"""

from __future__ import annotations

import argparse
import configparser
import csv
import json
import sys
import time
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import requests
from requests.auth import HTTPBasicAuth


# ----------------- Config / helpers -----------------

@dataclass
class InstanceConfig:
    base_url: str   # e.g. https://your-site.atlassian.net/wiki  (or without /wiki; we normalize)
    username: str   # email used to log in
    token: str      # API token (PAT)


def normalize_cloud_base_url(url: str) -> str:
    url = (url or "").strip().rstrip("/")
    # Accept either https://site.atlassian.net or https://site.atlassian.net/wiki
    return url


def cloud_rest_root(base_url: str) -> str:
    # Cloud REST v1 lives under /wiki/rest/api
    if base_url.lower().endswith("/wiki"):
        return f"{base_url}/rest/api"
    return f"{base_url}/wiki/rest/api"


def read_ini(ini_path: str, section: str) -> InstanceConfig:
    cfg = configparser.ConfigParser()
    cfg.read(ini_path, encoding="utf-8")

    if section not in cfg:
        raise SystemExit(f"ERROR: INI section [{section}] not found in {ini_path}")

    base_url = cfg[section].get("url", "").strip()
    username = cfg[section].get("username", "").strip()
    token = (cfg[section].get("pat", "") or cfg[section].get("token", "") or cfg[section].get("password", "")).strip()

    if not base_url or not username or not token:
        raise SystemExit("ERROR: INI section must include url, username, and pat (or token/password).")

    return InstanceConfig(
        base_url=normalize_cloud_base_url(base_url),
        username=username,
        token=token,
    )


def headers_json() -> Dict[str, str]:
    return {"Accept": "application/json", "Content-Type": "application/json"}


def read_users_csv(path: str) -> List[Dict[str, str]]:
    with open(path, "r", encoding="utf-8-sig", newline="") as f:
        reader = csv.DictReader(f)
        if not reader.fieldnames:
            raise SystemExit("ERROR: CSV has no headers.")
        return [{(k or "").strip(): (v or "").strip() for k, v in row.items()} for row in reader]


# ----------------- Confluence calls -----------------

def add_space_permission(
    session: requests.Session,
    rest_root: str,
    space_key: str,
    account_id: str,
    op_key: str,
    op_target: str,
    dry_run: bool,
) -> Tuple[bool, str]:
    """
    POST /wiki/rest/api/space/{spaceKey}/permission
    """
    url = f"{rest_root}/space/{space_key}/permission"
    payload = {
        "subject": {"type": "user", "identifier": account_id},
        "operation": {"key": op_key, "target": op_target},
        "_links": {},
    }

    if dry_run:
        return True, f"DRY-RUN: would POST {url} {json.dumps(payload)}"

    r = session.post(url, headers=headers_json(), data=json.dumps(payload), timeout=60)
    if r.status_code in (200, 201):
        return True, "OK"

    # Duplicate permissions sometimes return 400; include body for troubleshooting
    body = (r.text or "").strip()
    return False, f"HTTP {r.status_code}: {body[:500]}"


def resolve_account_id_best_effort(
    session: requests.Session,
    rest_root: str,
    row: Dict[str, str],
) -> Optional[str]:
    """
    Strongly prefer accountId already supplied in CSV.
    If not present: best-effort lookup via /wiki/rest/api/search/user (CQL)

    NOTE: Many orgs disable email-based lookup; privacy may null email/displayName fields.
    """
    acct = row.get("accountId") or row.get("account_id") or row.get("AccountId") or row.get("Account ID")
    if acct:
        return acct.strip() or None

    # Try to search by a provided "query" or "email"
    query = row.get("query") or row.get("email") or row.get("Email") or ""
    query = query.strip()
    if not query:
        return None

    # Confluence Cloud user search endpoint expects CQL in "cql" parameter
    # Example: cql=user.fullname~"Jane"  OR user.accountid="..."
    # Do a broad user query: user~"<query>"
    url = f"{rest_root}/search/user"
    params = {"cql": f'user~"{query}"', "limit": 25}

    r = session.get(url, params=params, timeout=60)
    if r.status_code != 200:
        return None

    try:
        data = r.json()
        results = data.get("results", []) if isinstance(data, dict) else []
        # Each result should contain user fields; we look for accountId.
        for item in results:
            user = item.get("user") if isinstance(item, dict) else None
            if isinstance(user, dict) and user.get("accountId"):
                return user["accountId"]
    except Exception:
        return None

    return None


# ----------------- Main -----------------

def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--ini", required=True, help="Path to INI file (e.g., jira_config.ini)")
    ap.add_argument("--section", required=True, help="INI section name for the Confluence Cloud instance")
    ap.add_argument("--spacekey", required=True, help="Confluence space key (e.g., VISO)")
    ap.add_argument("--csv", required=True, help="CSV file (prefer: accountId column; optional: email/query)")
    ap.add_argument("--dry-run", action="store_true", help="Do not change anything; show intended calls.")
    ap.add_argument("--sleep-ms", type=int, default=150, help="Delay between API calls (default 150ms)")
    ap.add_argument("--out", default="space_permission_results.csv", help="Output CSV report")
    args = ap.parse_args()

    inst = read_ini(args.ini, args.section)
    rest_root = cloud_rest_root(inst.base_url)

    session = requests.Session()
    session.auth = HTTPBasicAuth(inst.username, inst.token)

    # Permissions to grant (view + create content)
    ops = [
        ("read", "space"),
        ("create", "page"),
        ("create", "blogpost"),
        ("create", "comment"),
        ("create", "attachment"),
    ]

    rows = read_users_csv(args.csv)
    report: List[Dict[str, str]] = []

    for i, row in enumerate(rows, start=1):
        account_id = resolve_account_id_best_effort(session, rest_root, row)

        if not account_id:
            report.append({
                "row": str(i),
                "accountId": row.get("accountId", "") or row.get("account_id", ""),
                "email": row.get("email", "") or row.get("Email", ""),
                "status": "SKIP",
                "detail": "Could not resolve accountId. Provide accountId in CSV for reliable results.",
            })
            continue

        ok_all = True
        details: List[str] = []
        for op_key, op_target in ops:
            ok, msg = add_space_permission(session, rest_root, args.spacekey, account_id, op_key, op_target, args.dry_run)
            ok_all = ok_all and ok
            details.append(f"{op_key}:{op_target}={msg}")
            time.sleep(max(0, args.sleep_ms) / 1000.0)

        report.append({
            "row": str(i),
            "accountId": account_id,
            "email": row.get("email", "") or row.get("Email", ""),
            "status": "OK" if ok_all else "PARTIAL/FAIL",
            "detail": " | ".join(details)[:2000],
        })

    fieldnames = ["row", "accountId", "email", "status", "detail"]
    with open(args.out, "w", encoding="utf-8", newline="") as f:
        w = csv.DictWriter(f, fieldnames=fieldnames)
        w.writeheader()
        for r in report:
            w.writerow({k: r.get(k, "") for k in fieldnames})

    print(f"Done. Report written to: {args.out}")
    print(f"Used REST root: {rest_root}")
    print("NOTE: You need Space Admin permissions to add space permissions via this endpoint.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
